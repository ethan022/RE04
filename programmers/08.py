# ============================================================================
# 문제 1: 다항식 더하기
# ============================================================================
'''
개념 설명:
    - 다항식: 한 개 이상의 항의 합으로 이루어진 식 (예: 3x + 7 + 2x)
    - 동류항: 같은 문자와 차수를 가진 항 (예: 3x와 2x는 동류항)
    - 동류항끼리 계산: 계수만 더하면 됨 (3x + 2x = 5x)
    
문제 해결 전략:
    1. 문자열을 " + "로 분리하여 각 항을 추출
    2. x가 포함된 항은 x계수를 추출 (없으면 1로 처리)
    3. x가 없는 항은 상수항으로 처리
    4. 각각 합산한 후 결과 문자열 생성
    
핵심 포인트:
    - "x"는 계수가 1인 경우 (1x가 아닌 x로 표현)
    - 계수가 0인 경우 해당 항은 생략
    - 가장 짧은 형태로 표현 (1x → x)
'''


def solution(polynomial):
    # 입력 문자열을 " + "로 분리하여 각 항을 리스트로 만듦
    terms = polynomial.split(" + ")

    x_sum = 0      # x항의 계수 합계
    const_sum = 0  # 상수항 합계

    # 각 항을 순회하며 처리
    for term in terms:
        if 'x' in term:  # x항인 경우
            # 'x'를 제거하여 계수만 추출
            # 예: "3x" → "3", "x" → ""
            x_num = term.replace('x', '')

            # 계수가 비어있으면 1, 아니면 정수로 변환
            # "x"의 경우 계수가 1이므로 1로 처리
            x_sum += int(x_num) if x_num else 1

        else:  # 상수항인 경우
            const_sum += int(term)

    # 결과 문자열을 만들기 위한 리스트
    answer = []

    # x항이 0이 아닌 경우 추가
    if x_sum:
        # 계수가 1이면 "x", 아니면 "계수x" 형태로 추가
        # 1x가 아닌 x로 표현하여 가장 짧은 형태 유지
        answer.append(f'{x_sum}x' if x_sum > 1 else 'x')

    # 상수항이 0이 아닌 경우 추가
    if const_sum:
        answer.append(str(const_sum))

    # 리스트를 " + "로 연결하여 최종 문자열 반환
    return " + ".join(answer)


# 테스트 케이스
print('==== 다항식 더하기 ====')
print(solution("3x + 7 + x"))      # "4x + 7" (3x + x = 4x)
print(solution("x + x + x"))        # "3x" (x + x + x = 3x)
print(solution("3x + 5 + 2x + 7"))  # "5x + 12" (3x + 2x = 5x, 5 + 7 = 12)
print(solution("x"))                # "x" (단일 항)
print(solution("10"))               # "10" (상수항만)
print()


# ============================================================================
# 문제 2: 숨어있는 숫자의 덧셈 (2)
# ============================================================================
'''
개념 설명:
    - 문자열에서 연속된 숫자를 하나의 수로 인식
    - 예: "a1B2c34" → 1, 2, 34를 찾아서 합산
    
문제 해결 전략:
    1. 문자열을 순회하며 숫자인지 확인
    2. 숫자가 연속되면 하나의 수로 누적
    3. 문자를 만나면 누적된 숫자를 합산하고 초기화
    4. 마지막에 남은 숫자 처리
    
핵심 포인트:
    - 연속된 숫자는 하나의 수 (예: "34"는 3과 4가 아닌 34)
    - isdigit() 메서드로 숫자 판별
    - 문자열 끝에 숫자가 있을 경우 별도 처리 필요
'''


def solution(my_string):
    total = 0   # 전체 합계
    num = ""    # 현재 누적 중인 숫자 문자열

    # 문자열의 각 문자를 순회
    for ch in my_string:
        if ch.isdigit():  # 현재 문자가 숫자인지 판별
            # 숫자면 누적 (예: num = "3" → num = "34")
            num += ch
        else:
            # 문자를 만났을 때
            if num:  # 누적된 숫자가 있으면
                total += int(num)  # 정수로 변환하여 합산
                num = ""           # 누적 숫자 초기화

    # 문자열이 숫자로 끝나는 경우를 처리
    # 예: "1a2b3" → 마지막 3이 num에 남아있음
    if num:
        total += int(num)

    return total


# 테스트 케이스
print('==== 숨어있는 숫자의 덧셈 (2) ====')
print(solution("aAb1B2cC34oOp"))   # 37 (1 + 2 + 34)
print(solution("1a2b3c4d123Z"))    # 133 (1 + 2 + 3 + 4 + 123)
print(solution("abc123def456"))    # 579 (123 + 456)
print(solution("1a1a1a"))          # 3 (1 + 1 + 1)
print(solution("abcde"))           # 0 (숫자 없음)
print()


# ============================================================================
# 문제 3: 안전지대
# ============================================================================
'''
개념 설명:
    - 지뢰 위치와 그 주변 8칸은 위험지역
    - 위험지역이 아닌 안전한 칸의 개수를 구함
    
문제 해결 전략:
    1. 위험지역 표시용 2차원 배열 생성
    2. 지뢰(1) 위치를 찾으면 주변 8방향을 위험지역으로 표시
    3. 위험지역이 아닌 칸의 개수를 세어 반환
    
8방향 좌표 이해:
    현재 위치 (i, j)를 기준으로:
    (-1,-1)  (-1, 0)  (-1, 1)   ↖ ↑ ↗
    ( 0,-1)  ( 0, 0)  ( 0, 1)   ← ● →
    ( 1,-1)  ( 1, 0)  ( 1, 1)   ↙ ↓ ↘
    
핵심 포인트:
    - 8방향 모두 체크 (상하좌우 + 대각선 4방향)
    - 보드 범위를 벗어나지 않는지 확인 (0 <= nx < n)
    - 위험지역 중복 표시 가능 (여러 지뢰의 영향권이 겹칠 수 있음)
'''


def solution(board):
    # n×n 크기의 정사각형 보드 크기 확인
    n = len(board)

    # 위험 지역 표시용 2차원 배열 초기화
    # 0: 안전, 1: 위험
    danger = [[0] * n for _ in range(n)]

    # 8방향 이동을 위한 방향 벡터
    # (행 변화량, 열 변화량) 형태
    directions = [
        (-1, -1), (-1, 0), (-1, 1),  # 왼쪽 위, 위, 오른쪽 위
        (0, -1),  (0, 0),  (0, 1),   # 왼쪽, 현재, 오른쪽
        (1, -1),  (1, 0),  (1, 1)    # 왼쪽 아래, 아래, 오른쪽 아래
    ]

    # 보드 전체를 순회하며 지뢰 찾기
    for i in range(n):
        for j in range(n):
            if board[i][j] == 1:  # 지뢰를 발견한 경우
                # 현재 위치를 포함한 8방향을 위험지역으로 표시
                for dx, dy in directions:
                    # 새로운 좌표 계산
                    nx, ny = i + dx, j + dy

                    # 새로운 좌표가 보드 범위 내에 있는지 확인
                    # 범위: 0 <= nx < n, 0 <= ny < n
                    if 0 <= nx < n and 0 <= ny < n:
                        danger[nx][ny] = 1  # 위험지역으로 표시

    # 안전한 지역(danger[i][j] == 0) 개수 세기
    safe_count = 0
    for i in range(n):
        for j in range(n):
            if danger[i][j] == 0:
                safe_count += 1

    return safe_count


# 테스트 케이스
print('==== 안전지대 ====')

# 테스트 1: 중앙에 지뢰 1개
# 지뢰와 주변 8칸이 위험 = 9칸
# 전체 25칸 - 9칸 = 16칸 안전
result1 = solution([
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0]
])
print(f'테스트 1 결과: {result1}')  # 16

# 테스트 2: 인접한 지뢰 2개
# 지뢰 2개와 겹치는 부분을 고려한 위험지역
# 위험지역이 일부 겹치므로 안전지역이 더 많음
result2 = solution([
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 0, 0, 0, 0]
])
print(f'테스트 2 결과: {result2}')  # 13

# 테스트 3: 모서리에 지뢰
# 모서리는 영향 범위가 작음
result3 = solution([
    [1, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
])
print(f'테스트 3 결과: {result3}')  # 5 (9칸 중 4칸 위험)

# 테스트 4: 지뢰가 없는 경우
result4 = solution([
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
])
print(f'테스트 4 결과: {result4}')  # 9 (모두 안전)

print()


# ============================================================================
# 추가 설명: 각 문제의 시간 복잡도
# ============================================================================
'''
1. 다항식 더하기:
   - 시간 복잡도: O(n), n은 항의 개수
   - 공간 복잡도: O(n), 분리된 항을 저장
   
2. 숨어있는 숫자의 덧셈:
   - 시간 복잡도: O(n), n은 문자열 길이
   - 공간 복잡도: O(k), k는 가장 긴 연속 숫자의 길이
   
3. 안전지대:
   - 시간 복잡도: O(n²), n×n 보드를 순회
   - 공간 복잡도: O(n²), danger 배열 생성
   - 각 지뢰마다 8방향 체크: O(8) = O(1)
   - 전체: O(n²) × O(1) = O(n²)
'''

# ============================================================================
# 핵심 개념 정리
# ============================================================================
'''
1. 문자열 처리:
   - split(): 구분자로 문자열 분리
   - replace(): 특정 문자 제거/대체
   - isdigit(): 숫자 판별
   - join(): 리스트를 문자열로 연결
   
2. 2차원 배열:
   - 리스트 컴프리헨션으로 초기화
   - [[0] * n for _ in range(n)]
   
3. 방향 벡터:
   - 8방향 이동: 상하좌우 + 대각선
   - (dx, dy) 형태로 방향 표현
   - 경계 체크: 0 <= nx < n
   
4. 알고리즘 패턴:
   - 누적 (accumulation): 연속된 값 모으기
   - 플러드 필 (flood fill): 특정 위치에서 확산
   - 카운팅: 조건을 만족하는 요소 세기
'''
# ============================================================================
