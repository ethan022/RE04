# NumPy 배열 모양 변경과 조작 완전 가이드

import numpy as np

# ============================================================================
# 1. 배열의 속성: shape, ndim, size
# ============================================================================
# shape: 각 차원의 크기를 나타내는 튜플
# ndim: 배열의 차원 수 (1차원, 2차원, 3차원 등)
# size: 배열의 전체 요소 개수

arr_1d = np.array([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])

print('====== 1차원 배열 ======')
print('shape:', arr_1d.shape)  # (12,) - 12개의 요소를 가진 1차원 배열
print('ndim:', arr_1d.ndim)    # 1 - 1차원
print('size:', arr_1d.size)    # 12 - 총 12개의 요소

# reshape: 배열의 모양을 변경 (단, 전체 요소 개수는 유지되어야 함)
# reshape(4, -1): 4행으로 만들고, 열은 자동 계산 (-1은 자동 계산을 의미)
# 12개 요소를 4행으로 나누면 -> 4행 3열
print('4행으로 변형:\n', arr_1d.reshape(4, -1))
print()

arr_2d = np.array([[1, 2, 3], [4, 5, 6]])

print('====== 2차원 배열 ======')
print('shape:', arr_2d.shape)  # (2, 3) - 2행 3열
print('ndim:', arr_2d.ndim)    # 2 - 2차원
print('size:', arr_2d.size)    # 6 - 총 6개의 요소 (2 × 3)
print()

# ============================================================================
# 2. 배열 간 기본 산술 연산 (Element-wise Operations)
# ============================================================================
# NumPy는 같은 크기의 배열끼리 요소별(element-wise)로 연산을 수행
# 각 위치의 요소들끼리 연산이 이루어짐

a = np.array([1, 2, 3, 4, 5])
b = np.array([5, 4, 3, 2, 1])

print('배열 a:', a)
print('배열 b:', b)
print()

# 덧셈: 같은 위치의 요소끼리 더함
print('덧셈 (a + b):', a + b)  # [1+5, 2+4, 3+3, 4+2, 5+1] = [6, 6, 6, 6, 6]

# 뺄셈: 같은 위치의 요소끼리 뺌
print('뺄셈 (a - b):', a - b)  # [1-5, 2-4, 3-3, 4-2, 5-1] = [-4, -2, 0, 2, 4]

# 곱셈: 같은 위치의 요소끼리 곱함 (행렬 곱셈이 아님!)
print('곱셈 (a * b):', a * b)  # [1*5, 2*4, 3*3, 4*2, 5*1] = [5, 8, 9, 8, 5]

# 거듭제곱: a의 각 요소를 b의 해당 요소만큼 제곱
# [1^5, 2^4, 3^3, 4^2, 5^1] = [1, 16, 27, 16, 5]
print('거듭제곱 (a ** b):', a ** b)

# 나눗셈: 같은 위치의 요소끼리 나눔 (결과는 실수)
# [1/5, 2/4, 3/3, 4/2, 5/1] = [0.2, 0.5, 1.0, 2.0, 5.0]
print('나눗셈 (a / b):', a / b)

# 정수 나눗셈: 몫만 반환
# [1//5, 2//4, 3//3, 4//2, 5//1] = [0, 0, 1, 2, 5]
print('몫 (a // b):', a // b)

# 나머지 연산
print('나머지 (a % b):', a % b)  # [1%5, 2%4, 3%3, 4%2, 5%1] = [1, 2, 0, 0, 0]
print()

# ============================================================================
# 3. 스칼라와의 연산 (Broadcasting의 기본 형태)
# ============================================================================
# 스칼라(단일 값)는 자동으로 배열의 모든 요소와 연산됨
# 이것이 브로드캐스팅의 가장 기본적인 예시

a = np.array([1, 2, 3, 4, 5])
scalar = 10

print('원본 배열 a:', a)
print()

# 스칼라 10이 [10, 10, 10, 10, 10]으로 브로드캐스트됨
print('+ 스칼라 10:', a + scalar)  # [11, 12, 13, 14, 15]
print('- 스칼라 10:', a - scalar)  # [-9, -8, -7, -6, -5]
print('* 스칼라 10:', a * scalar)  # [10, 20, 30, 40, 50]
print('/ 스칼라 10:', a / scalar)  # [0.1, 0.2, 0.3, 0.4, 0.5]

# 순서를 바꿔도 작동 (교환법칙 성립)
print('스칼라 10 / 배열:', scalar / a)  # [10/1, 10/2, 10/3, 10/4, 10/5]
print()

# ============================================================================
# 4. 2차원 배열(행렬) 간의 연산
# ============================================================================
# 같은 크기의 행렬끼리는 요소별로 연산됨

A = np.array([
    [1, 2, 3],
    [4, 5, 6]
])
B = np.array([
    [7, 8, 9],
    [10, 11, 12]
])

print('행렬 A:\n', A)
print('행렬 B:\n', B)
print()

# 행렬 덧셈: 같은 위치의 요소끼리 더함
print('행렬 A + B:\n', A + B)
# 결과: [[1+7, 2+8, 3+9],    [[8, 10, 12],
#       [4+10, 5+11, 6+12]] = [14, 16, 18]]
print()

# 행렬 요소별 곱셈: 같은 위치의 요소끼리 곱함 (Hadamard product)
# 주의: 수학의 행렬 곱셈과는 다름!
print('행렬 A * B (요소별 곱셈):\n', A * B)
# 결과: [[1*7, 2*8, 3*9],    [[7, 16, 27],
#       [4*10, 5*11, 6*12]] = [40, 55, 72]]
print()

# 행렬 요소별 나눗셈
print('행렬 A / B:\n', A / B)
print()

# ============================================================================
# 5. 행렬 곱셈 (Matrix Multiplication)
# ============================================================================
# @ 연산자 또는 np.matmul()을 사용하여 수학적 행렬 곱셈 수행
# A(m×n) @ B(n×p) = C(m×p)
# 첫 번째 행렬의 열 개수와 두 번째 행렬의 행 개수가 같아야 함

A = np.array([
    [1, 2],
    [3, 4]
])
B = np.array([
    [7, 8],
    [9, 10]
])

print('행렬 A (2×2):\n', A)
print('행렬 B (2×2):\n', B)
print()

# 행렬 곱셈: A @ B
# 결과[i,j] = A의 i번째 행과 B의 j번째 열의 내적
print('행렬 곱셈 (A @ B):\n', A @ B)
# 계산 과정:
# [1,2] · [7,9] = 1*7 + 2*9 = 25    [1,2] · [8,10] = 1*8 + 2*10 = 28
# [3,4] · [7,9] = 3*7 + 4*9 = 57    [3,4] · [8,10] = 3*8 + 4*10 = 52
# 결과: [[25, 28],
#       [57, 62]]
print()

# ============================================================================
# 6. 브로드캐스팅(Broadcasting) 개념
# ============================================================================
# 브로드캐스팅: 서로 다른 크기의 배열 간 연산을 가능하게 하는 NumPy의 강력한 기능
# 작은 배열을 자동으로 큰 배열의 크기에 맞춰 확장하여 연산 수행

# 예제 1: 1차원 배열과 스칼라
arr = np.array([1, 2, 3, 4, 5])
scalar = 10

# 스칼라 10이 [10, 10, 10, 10, 10]으로 브로드캐스트됨
result = arr + scalar  # [11, 12, 13, 14, 15]

# 예제 2: 2차원 배열과 1차원 배열
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])
vector = np.array([10, 20, 30])

print('행렬 (3×3):\n', matrix)
print('벡터 (3,):', vector)
print()

# vector가 각 행에 브로드캐스트됨
print('행렬 + 벡터:\n', matrix + vector)
# 과정:
# [[1, 2, 3],     [[10, 20, 30],     [[11, 22, 33],
#  [4, 5, 6],  +   [10, 20, 30],  =   [14, 25, 36],
#  [7, 8, 9]]      [10, 20, 30]]      [17, 28, 39]]
print()

# ============================================================================
# 7. 브로드캐스팅 규칙
# ============================================================================
# 규칙 1: 차원 수가 다르면 작은 배열의 shape 앞에 1을 추가
# 규칙 2: 각 차원에서 크기가 1이거나 같아야 호환 가능
# 규칙 3: 크기가 1인 차원은 다른 배열의 해당 차원 크기로 확장됨

# 예제: (3,) + (3, 1)
a = np.array([1, 2, 3])           # shape: (3,)
b = np.array([[4], [5], [6]])     # shape: (3, 1)

# 브로드캐스팅 과정:
# 1. a의 shape을 (1, 3)으로 확장
# 2. (1, 3) + (3, 1) 연산
# 3. 각 차원에서 브로드캐스트:
#    - 첫 번째 차원: 1 → 3으로 확장
#    - 두 번째 차원: 3 ← 1로 확장
# 4. 최종 결과 shape: (3, 3)

print('a (3,):', a)
print('b (3, 1):\n', b)
print()
print('a + b 결과 (3, 3):\n', a + b)
# 결과:
# [[1+4, 2+4, 3+4],     [[5, 6, 7],
#  [1+5, 2+5, 3+5],  =   [6, 7, 8],
#  [1+6, 2+6, 3+6]]      [7, 8, 9]]
print()

# 규칙 2 예제: 호환 가능한 shape
# (4, 3) + (3,) → (4, 3) + (1, 3) → (4, 3)
a = np.ones((4, 3))  # 4행 3열
b = np.ones((3,))    # 3개 요소

print('(4, 3) + (3,) 연산:')
print('결과 shape:', (a + b).shape)  # (4, 3)
print(a + b)
print()

# 호환 불가능한 예: (3, 2) + (1, 4)
# 두 번째 차원에서 2와 4가 서로 다르고 둘 다 1이 아니므로 에러 발생
# a = np.ones((3, 2))
# b = np.ones((1, 4))
# print(a + b)  # ValueError: operands could not be broadcast together

# ============================================================================
# 8. 집계 함수 (Aggregation Functions)
# ============================================================================
# NumPy는 배열의 통계량을 계산하는 다양한 함수를 제공

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])

print('원본 배열:', arr)
print()

# 기본 통계 함수들
print('합계 (sum):', np.sum(arr))          # 45
print('평균 (mean):', np.mean(arr))        # 5.0
print('중앙값 (median):', np.median(arr))  # 5.0
print('표준편차 (std):', np.std(arr))      # 약 2.58
print('최댓값 (max):', np.max(arr))        # 9
print('최솟값 (min):', np.min(arr))        # 1
print('분산 (var):', np.var(arr))          # 약 6.67
print('범위 (ptp):', np.ptp(arr))          # 9 - 1 = 8 (peak to peak)
print()

# 누적 연산: 각 위치까지의 누적값을 배열로 반환
print('누적 합 (cumsum):', np.cumsum(arr))
# [1, 1+2, 1+2+3, ..., 1+2+...+9] = [1, 3, 6, 10, 15, 21, 28, 36, 45]

print('누적 곱 (cumprod):', np.cumprod(arr))
# [1, 1*2, 1*2*3, ..., 1*2*...*9] = [1, 2, 6, 24, 120, ...]
print()

# ============================================================================
# 9. 축(axis)을 따른 연산
# ============================================================================
# axis: 연산을 수행할 방향을 지정
# - axis=0: 열 방향 (세로, ↓) - 각 열에 대해 행들을 따라 연산
# - axis=1: 행 방향 (가로, →) - 각 행에 대해 열들을 따라 연산
# - axis=None: 전체 배열에 대해 연산 (기본값)

matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

print('행렬:\n', matrix)
print()

# 행별 합 (axis=1): 각 행의 요소들을 모두 더함
print('행별 합 (axis=1):', np.sum(matrix, axis=1))
# [1+2+3, 4+5+6, 7+8+9] = [6, 15, 24]

# 열별 합 (axis=0): 각 열의 요소들을 모두 더함
print('열별 합 (axis=0):', np.sum(matrix, axis=0))
# [1+4+7, 2+5+8, 3+6+9] = [12, 15, 18]
print()

# 평균도 동일한 방식으로 작동
print('행별 평균 (axis=1):', np.mean(matrix, axis=1))
# [평균(1,2,3), 평균(4,5,6), 평균(7,8,9)] = [2.0, 5.0, 8.0]

print('열별 평균 (axis=0):', np.mean(matrix, axis=0))
# [평균(1,4,7), 평균(2,5,8), 평균(3,6,9)] = [4.0, 5.0, 6.0]
print()

# ============================================================================
# 10. 축을 따른 누적 연산
# ============================================================================
# cumsum과 cumprod도 axis를 지정할 수 있음

# 행별 누적 합 (axis=1): 각 행 내에서 왼쪽에서 오른쪽으로 누적
print('행별 누적 합 (axis=1):\n', np.cumsum(matrix, axis=1))
# [[1, 1+2, 1+2+3],         [[1, 3, 6],
#  [4, 4+5, 4+5+6],      =   [4, 9, 15],
#  [7, 7+8, 7+8+9]]          [7, 15, 24]]

# 열별 누적 합 (axis=0): 각 열 내에서 위에서 아래로 누적
print('열별 누적 합 (axis=0):\n', np.cumsum(matrix, axis=0))
# [[1,   2,   3],           [[1,  2,  3],
#  [1+4, 2+5, 3+6],      =   [5,  7,  9],
#  [1+4+7, 2+5+8, 3+6+9]]    [12, 15, 18]]
print()

# ============================================================================
# 핵심 개념 요약
# ============================================================================
# 1. 배열 속성:
#    - shape: 각 차원의 크기
#    - ndim: 차원 수
#    - size: 전체 요소 개수
#
# 2. 산술 연산:
#    - 같은 크기의 배열: 요소별(element-wise) 연산
#    - 행렬 곱셈: @ 연산자 사용
#
# 3. 브로드캐스팅:
#    - 다른 크기의 배열 간 연산을 자동으로 처리
#    - 규칙: 차원 맞춤 → 크기 1인 차원 확장
#
# 4. 집계 함수:
#    - sum, mean, median, std, max, min 등
#    - cumsum, cumprod: 누적 연산
#
# 5. axis 파라미터:
#    - axis=0: 열 방향 (세로)
#    - axis=1: 행 방향 (가로)
#    - axis=None: 전체 배열
# ============================================================================
