# NumPy 배열 인덱싱과 슬라이싱 완전 가이드

import numpy as np

# ============================================================================
# 1. 팬시 인덱싱 (Fancy Indexing)
# ============================================================================
# 팬시 인덱싱: 정수 배열을 사용하여 원하는 위치의 요소들을 선택하는 방법
# 일반 인덱싱과 달리 여러 요소를 한 번에 선택할 수 있으며, 순서와 중복도 가능

arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
print('원본 배열 arr:\n', arr)

# 인덱스 리스트를 사용하여 원하는 요소들만 선택
# 같은 인덱스를 여러 번 사용할 수 있고, 순서도 자유롭게 지정 가능
indices = [1, 3, 1, 7, 4, 7]
print('인덱스 [1, 3, 1, 7, 4, 7] 선택:\n', arr[indices])
# 결과: [20, 40, 20, 80, 50, 80] - 인덱스 1과 7이 중복되어 선택됨

print()

# ============================================================================
# 2. 양수 인덱싱 (Positive Indexing)
# ============================================================================
# 배열의 앞에서부터 0, 1, 2, ... 순서로 접근
# 인덱스는 0부터 시작하므로 첫 번째 요소는 arr[0]

print('첫번째 요소 (인덱스 0):', arr[0])  # 10
print('세번째 요소 (인덱스 2):', arr[2])  # 30
print('아홉번째 요소 (인덱스 8):', arr[8])  # 90
# print('열번째 요소 (인덱스 9):', arr[9])  # IndexError: 배열 크기를 벗어남

# 인덱싱을 통한 값 수정
# 특정 인덱스의 값을 직접 변경할 수 있음
arr[0] = 100
print('수정 후 배열 arr:\n', arr)  # 첫 번째 요소가 100으로 변경됨

print()

# ============================================================================
# 3. 음수 인덱싱 (Negative Indexing)
# ============================================================================
# 배열의 뒤에서부터 -1, -2, -3, ... 순서로 접근
# -1은 마지막 요소, -2는 마지막에서 두 번째 요소를 의미

print('마지막 요소 (인덱스 -1):', arr[-1])  # 90
print('마지막에서 두번째 요소 (인덱스 -2):', arr[-2])  # 80
print('마지막에서 여덟번째 요소 (인덱스 -8):', arr[-8])  # 20

# 음수 인덱스로도 값 수정 가능
arr[-3] = 400  # 뒤에서 세 번째 요소를 400으로 변경
print('수정 후 배열 arr:\n', arr)

print()

# ============================================================================
# 4. 배열 슬라이싱 (Array Slicing)
# ============================================================================
# 슬라이싱: 배열의 일부분을 연속적으로 추출하는 방법
# 형식: arr[start:stop:step]
#   - start: 시작 인덱스 (포함)
#   - stop: 종료 인덱스 (제외)
#   - step: 간격 (기본값 1)

arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
print('원본 배열 arr:\n', arr)

# 기본 슬라이싱 예제
print('인덱스 2부터 5까지 (5 제외):', arr[2:5])  # [30, 40, 50]
print('인덱스 처음부터 4까지 (4 제외):', arr[:4])  # [10, 20, 30, 40]
print('인덱스 3부터 마지막까지:', arr[3:])  # [40, 50, 60, 70, 80, 90]

# step을 사용한 슬라이싱
print('짝수 인덱스만 (0, 2, 4, ...):', arr[::2])  # [10, 30, 50, 70, 90]
print('홀수 인덱스만 (1, 3, 5, ...):', arr[1::2])  # [20, 40, 60, 80]

print()

# ============================================================================
# 5. 슬라이싱으로 값 수정
# ============================================================================
# 슬라이싱으로 선택한 범위의 값들을 한 번에 수정 가능

# 단일 값으로 수정 - 선택한 모든 요소가 같은 값으로 변경됨
arr[2:5] = 100
print('인덱스 2~4를 100으로 수정:\n', arr)

# 배열로 수정 - 선택한 요소들을 각각 다른 값으로 변경
# 주의: 슬라이스 범위와 할당하는 배열의 길이가 같아야 함
arr[2:5] = [10, 20, 30]
print('인덱스 2~4를 [10, 20, 30]으로 수정:\n', arr)

# arr[2:5] = [10, 20]  # ValueError: 길이가 맞지 않음 (3개 위치에 2개 값)

print()

# ============================================================================
# 6. 뷰(View)와 복사(Copy)
# ============================================================================
# 중요 개념: NumPy의 슬라이싱은 '뷰(View)'를 반환
# 뷰는 원본 데이터를 참조하므로, 뷰를 수정하면 원본도 변경됨

original = np.array([1, 2, 3, 4, 5])
view = original[1:4]  # 뷰 생성 (원본 데이터를 참조)
print('original:\n', original)  # [1, 2, 3, 4, 5]
print('view:\n', view)  # [2, 3, 4]
print()

# 뷰를 수정하면 원본도 변경됨
view[0] = 10
print('view[0]을 10으로 수정 후:')
print('original:\n', original)  # [1, 10, 3, 4, 5] - 원본도 변경됨!
print('view:\n', view)  # [10, 3, 4]
print()

# 뷰의 여러 요소를 한 번에 수정
view[1:] = 20
print('view[1:]을 20으로 수정 후:')
print('original:\n', original)  # [1, 10, 20, 20, 5]
print('view:\n', view)  # [10, 20, 20]

print()

# ============================================================================
# 7. 독립적인 복사본 생성
# ============================================================================
# 원본과 독립적인 배열이 필요한 경우 .copy() 메서드 사용
# 복사본을 수정해도 원본은 영향을 받지 않음

original = np.array([1, 2, 3, 4, 5])
copy = original[1:4].copy()  # 독립적인 복사본 생성

copy[0] = 100
print('copy[0]을 100으로 수정 후:')
print('original:\n', original)  # [1, 2, 3, 4, 5] - 원본은 변경되지 않음
print('copy:\n', copy)  # [100, 3, 4] - 복사본만 변경됨

print()

# ============================================================================
# 8. 2차원 배열 인덱싱
# ============================================================================
# 2차원 배열은 [행, 열] 형식으로 접근
# matrix[i, j]는 i번째 행, j번째 열의 요소를 의미

matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

print('2차원 배열:\n', matrix)
print()

# 특정 요소 접근
print('(0, 0) 요소:', matrix[0, 0])  # 1 - 첫 번째 행, 첫 번째 열
print('(2, 2) 요소:', matrix[2, 2])  # 9 - 세 번째 행, 세 번째 열
print('(1, 2) 요소:', matrix[1, 2])  # 6 - 두 번째 행, 세 번째 열

# 두 가지 표기법: matrix[i, j]와 matrix[i][j]는 같은 결과
print('(1, 2) 요소 (대괄호 2번):', matrix[1][2])  # 6

# print('(3, 0) 요소:', matrix[3, 0])  # IndexError: 행 인덱스 범위 초과

# 음수 인덱스도 2차원 배열에서 사용 가능
print('(-1, -2) 요소:', matrix[-1, -2])  # 8 - 마지막 행, 뒤에서 두 번째 열
print('(-1, -2) 요소 (대괄호 2번):', matrix[-1][-2])  # 8

print()

# ============================================================================
# 9. 2차원 배열의 행 선택
# ============================================================================
# 단일 인덱스를 사용하면 전체 행을 선택

print('첫 번째 행:', matrix[0])  # [1, 2, 3]
print('두 번째 행:', matrix[1])  # [4, 5, 6]

# 슬라이싱으로 여러 행 선택
print('처음 두 행:\n', matrix[:2])  # [[1, 2, 3], [4, 5, 6]]

print()

# ============================================================================
# 10. 2차원 배열 슬라이싱 - 부분 행렬 추출
# ============================================================================
# 2차원 슬라이싱: matrix[행_범위, 열_범위]
# 행과 열을 각각 슬라이싱하여 부분 행렬을 추출

matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])

print('원본 행렬:\n', matrix)
print()

# 처음 두 행, 두 번째 열부터 끝까지
print('matrix[:2, 1:]:\n', matrix[:2, 1:])
# 결과: [[ 2  3  4  5]
#       [ 7  8  9 10]]
print()

# 두 번째~세 번째 행, 두 번째~네 번째 열
print('matrix[1:3, 1:4]:\n', matrix[1:3, 1:4])
# 결과: [[ 7  8  9]
#       [12 13 14]]
print()

# 짝수 행과 짝수 열만 선택 (step=2)
print('matrix[::2, ::2]:\n', matrix[::2, ::2])
# 결과: [[ 1  3  5]
#       [11 13 15]]

print()

# ============================================================================
# 11. 팬시 인덱싱으로 특정 행들 선택
# ============================================================================
# 정수 배열을 사용하여 원하는 행들만 선택

row_indices = [0, 2, 3]
print('[0, 2, 3]번 행 선택:\n', matrix[row_indices])
# 결과: [[ 1  2  3  4  5]
#       [11 12 13 14 15]
#       [16 17 18 19 20]]

print()

# ============================================================================
# 12. 팬시 인덱싱으로 특정 요소들 선택
# ============================================================================
# 행 인덱스 배열과 열 인덱스 배열을 동시에 사용
# (row_indices[i], col_indices[i]) 위치의 요소들을 선택

row_indices = [0, 2, 2]
col_indices = [3, 2, 3]
print('특정 요소들 선택 (0,3), (2,2), (2,3):\n',
      matrix[row_indices, col_indices])
# 결과: [ 4 13 14] - 각각 (0,3), (2,2), (2,3) 위치의 요소

print()

# ============================================================================
# 13. 불린 인덱싱 (Boolean Indexing) - 1차원 배열
# ============================================================================
# 조건식을 사용하여 조건을 만족하는 요소들만 선택
# 조건식은 True/False 배열을 반환하고, True인 위치의 요소만 선택됨

arr = np.array([1, 5, 4, 7, 2, 3])
print('원본 배열:', arr)

# 단일 조건
print('4 이상인 요소:', arr[arr >= 4])  # [5, 4, 7]

# 여러 조건 결합
# | (or): 둘 중 하나라도 True이면 선택
print('2 미만 또는 4 이상:', arr[(arr >= 4) | (arr < 2)])  # [1, 5, 4, 7]

# & (and): 둘 다 True여야 선택
print('2 이상 4 이하:', arr[(2 <= arr) & (arr <= 4)])  # [4, 2, 3]

print()

# ============================================================================
# 14. 불린 인덱싱 - 2차원 배열
# ============================================================================
# 2차원 배열에서도 조건을 만족하는 요소들을 선택 가능

matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])
print('원본 행렬:\n', matrix)
print()

# 9보다 큰 모든 요소 선택 (1차원 배열로 반환됨)
print('9보다 큰 요소들:', matrix[matrix > 9])
# 결과: [10 11 12 13 14 15 16 17 18 19 20]

# 특정 열의 조건으로 행 전체 선택
# 첫 번째 열(matrix[:, 0])의 값이 4 이상인 행들만 선택
print('첫 번째 열이 4 이상인 행들:\n', matrix[matrix[:, 0] >= 4])
# 결과: [[ 6  7  8  9 10]
#       [11 12 13 14 15]
#       [16 17 18 19 20]]

print()

# ============================================================================
# 15. 불린 인덱싱으로 값 수정
# ============================================================================
# 조건을 만족하는 모든 요소를 한 번에 수정 가능

matrix[matrix > 9] = 10  # 9보다 큰 모든 요소를 10으로 변경
print('9보다 큰 요소를 10으로 수정한 행렬:\n', matrix)
# 결과: [[ 1  2  3  4  5]
#       [ 6  7  8  9 10]
#       [10 10 10 10 10]
#       [10 10 10 10 10]]

# ============================================================================
# 핵심 개념 요약
# ============================================================================
# 1. 팬시 인덱싱: 정수 리스트로 원하는 요소들을 선택 (중복, 순서 변경 가능)
# 2. 양수/음수 인덱싱: 앞에서부터(0, 1, ...) 또는 뒤에서부터(-1, -2, ...)
# 3. 슬라이싱: [start:stop:step] 형식으로 연속된 범위 선택
# 4. 뷰 vs 복사: 슬라이싱은 뷰를 반환 (원본 참조), .copy()로 독립적인 복사본 생성
# 5. 2차원 인덱싱: [행, 열] 형식으로 접근
# 6. 불린 인덱싱: 조건식으로 조건을 만족하는 요소만 선택 및 수정
# ============================================================================
