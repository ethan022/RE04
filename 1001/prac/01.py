# NumPy 불린 인덱싱과 조건 연산 완전 가이드

import numpy as np

# ============================================================================
# 문제 1: 범위 내 값 필터링 (AND 조건)
# ============================================================================
'''
개념 설명:
    - 불린 인덱싱: 조건식을 사용하여 배열의 특정 요소만 선택
    - & (AND): 두 조건을 모두 만족하는 요소만 선택
    - 각 조건은 반드시 괄호로 묶어야 함
    
문제: 10보다 크고 20보다 작은 값 찾기
해결 과정:
    1. arr1 > 10 → [False, True, True, False, False, False]
    2. arr1 < 20 → [True, True, True, True, False, False]
    3. 두 조건 AND → [False, True, True, False, False, False]
    4. True인 위치의 값만 선택 → [12, 18]
'''

arr1 = np.array([5, 12, 18, 7, 30, 25])
print('원본 배열:', arr1)

# 조건별 결과 확인
print('10보다 큰가?', arr1 > 10)
print('20보다 작은가?', arr1 < 20)

# AND 조건: 두 조건을 모두 만족
result = arr1[(arr1 > 10) & (arr1 < 20)]
print('1. 결과 (10 < x < 20):', result)  # [12, 18]
print()

# ============================================================================
# 문제 2: 범위 밖 값 선택 (OR 조건)
# ============================================================================
'''
개념 설명:
    - | (OR): 두 조건 중 하나라도 만족하면 선택
    - 범위 밖의 값을 선택할 때 유용
    
문제: 15 이하이거나 30 이상인 값 찾기
해결 과정:
    1. arr2 <= 15 → [True, True, False, False, False, False]
    2. arr2 >= 30 → [False, False, False, False, True, True]
    3. 두 조건 OR → [True, True, False, False, True, True]
    4. True인 위치의 값만 선택 → [10, 15, 30, 35]
'''

arr2 = np.array([10, 15, 20, 25, 30, 35])
print('원본 배열:', arr2)

# 조건별 결과 확인
print('15 이하인가?', arr2 <= 15)
print('30 이상인가?', arr2 >= 30)

# OR 조건: 두 조건 중 하나라도 만족
result = arr2[(arr2 <= 15) | (arr2 >= 30)]
print('2. 결과 (x ≤ 15 또는 x ≥ 30):', result)  # [10, 15, 30, 35]
print()

# ============================================================================
# 문제 3: 조건에 맞는 값 변경
# ============================================================================
'''
개념 설명:
    - 불린 인덱싱으로 값을 직접 수정 가능
    - 조건을 만족하는 모든 요소를 한 번에 변경
    
문제: 10 이상인 값을 모두 0으로 변경
해결 과정:
    1. arr3 >= 10 → [False, False, True, False, False, True]
    2. True인 위치의 값을 0으로 변경
    3. [3, 8, 0, 6, 2, 0]
'''

arr3 = np.array([3, 8, 15, 6, 2, 20])
print('원본 배열:', arr3)
print('10 이상인가?', arr3 >= 10)

# 조건을 만족하는 요소를 0으로 변경
arr3[arr3 >= 10] = 0
print('3. 결과 (10 이상 → 0):', arr3)  # [3, 8, 0, 6, 2, 0]
print()

# ============================================================================
# 문제 4: 조건부 문자열 배열 생성 - np.where
# ============================================================================
'''
개념 설명:
    - np.where(조건, 참일_때_값, 거짓일_때_값)
    - 조건에 따라 다른 값을 가지는 새 배열 생성
    - 삼항 연산자와 유사한 개념
    
Python 삼항 연산자 복습:
    result = "참" if 조건 else "거짓"
    
문제: 20 이상이면 "High", 아니면 "Low"
해결 과정:
    1. arr4 >= 20 확인
    2. True인 위치 → "High"
    3. False인 위치 → "Low"
'''

# Python 삼항 연산자 예제
num = 8
result = "짝수" if num % 2 == 0 else "홀수"
print('삼항 연산자 예제:', result)

a, b = 30, 15
max_value = a if a > b else b
print('최댓값:', max_value)
print()

# np.where 사용
arr4 = np.array([7, 14, 21, 28, 35])
print('원본 배열:', arr4)
print('20 이상인가?', arr4 >= 20)

# 조건에 따라 "High" 또는 "Low" 할당
result = np.where(arr4 >= 20, "High", "Low")
print('4. 결과:', result)  # ['Low', 'Low', 'High', 'High', 'High']
print()

# ============================================================================
# 문제 5: 조건부 값 변환 - 짝수/홀수 처리
# ============================================================================
'''
개념 설명:
    - np.where로 원본 값을 조건부로 변환
    - 짝수는 그대로, 홀수는 10배로 변환
    
문제: 0~9에서 짝수는 유지, 홀수는 10배
해결 과정:
    1. arr5 % 2 == 0으로 짝수 판별
    2. 짝수면 arr5 (원본 값)
    3. 홀수면 arr5 * 10 (10배)
    
결과 예상:
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    → [0, 10, 2, 30, 4, 50, 6, 70, 8, 90]
'''

arr5 = np.arange(10)
print('원본 배열:', arr5)
print('짝수인가?', arr5 % 2 == 0)

# 짝수는 그대로, 홀수는 10배
result = np.where(arr5 % 2 == 0, arr5, arr5 * 10)
print('5. 결과 (홀수 × 10):', result)  # [0, 10, 2, 30, 4, 50, 6, 70, 8, 90]
print()

# ============================================================================
# 문제 6: 2차원 배열에서 범위 내 값 선택
# ============================================================================
'''
개념 설명:
    - 2차원 배열도 불린 인덱싱 사용 가능
    - 조건을 만족하는 요소만 1차원 배열로 반환
    - 마스크(mask): 조건식의 결과인 True/False 배열
    
문제: 20 이상 40 이하인 값 선택
해결 과정:
    1. 조건식으로 마스크 생성
    2. 마스크를 배열에 적용
    3. True인 위치의 값만 선택 (1차원으로 반환)
'''

arr6 = np.array([
    [10, 25, 30],
    [40, 5, 15],
    [20, 35, 50]
])
print('원본 2차원 배열:')
print(arr6)
print()

# 마스크(조건식 결과) 생성
mask = (arr6 >= 20) & (arr6 <= 40)
print('마스크 (20 ≤ x ≤ 40):')
print(mask)
print()

# 마스크를 사용하여 값 선택
result = arr6[mask]
print('6. 결과:', result)  # [25, 30, 40, 20, 35]
print()

# ============================================================================
# 문제 7: 특정 배수가 아닌 값 선택
# ============================================================================
'''
개념 설명:
    - != (not equal): 같지 않은 조건
    - % (나머지 연산자): 배수 판별에 사용
    - x % 3 == 0: 3의 배수
    - x % 3 != 0: 3의 배수가 아님
    
문제: 3의 배수가 아닌 값 선택
해결 과정:
    1. arr7 % 3 != 0으로 조건 생성
    2. True인 위치의 값만 선택
'''

arr7 = np.array([1, 2, 3, 4, 5, 6])
print('원본 배열:', arr7)

# 3으로 나눈 나머지 확인
print('3으로 나눈 나머지:', arr7 % 3)
print('3의 배수가 아닌가?', arr7 % 3 != 0)

# 3의 배수가 아닌 값만 선택
result = arr7[arr7 % 3 != 0]
print('7. 결과 (3의 배수 제외):', result)  # [1, 2, 4, 5]
print()

# ============================================================================
# 문제 8: 최솟값 보장 - 값 클리핑(Clipping)
# ============================================================================
'''
개념 설명:
    - 클리핑(Clipping): 특정 범위로 값을 제한
    - 50 미만인 값을 모두 50으로 올림 (최솟값 보장)
    - 데이터 전처리에서 자주 사용
    
문제: 50 이상은 유지, 50 미만은 50으로 변경
해결 과정:
    1. arr8 >= 50으로 조건 판별
    2. True(50 이상)면 원본 값 유지
    3. False(50 미만)면 50으로 변경
'''

np.random.seed(42)  # 재현 가능한 랜덤값
arr8 = np.random.randint(0, 101, 10)
print('원본 배열 (랜덤 0~100):', arr8)

# 50 이상은 그대로, 50 미만은 50으로
result = np.where(arr8 >= 50, arr8, 50)
print('8. 결과 (최소값 50 보장):', result)
print()

# 추가: np.clip 함수 사용 (더 직관적)
result_clip = np.clip(arr8, 50, 100)  # 50~100 범위로 제한
print('np.clip 사용:', result_clip)
print()

# ============================================================================
# 문제 9: 다중 조건 분류 - 중첩 np.where
# ============================================================================
'''
개념 설명:
    - 중첩 np.where: 3개 이상의 조건 처리
    - 바깥쪽부터 안쪽으로 조건 확인
    - if-elif-else 구조와 유사
    
문제: 3단계 등급 분류
    - 70 이상 → "A"
    - 30 이상 70 미만 → "B"
    - 30 미만 → "C"
    
해결 과정:
    1. 첫 번째 조건: arr9 >= 70
       - True → "A"
       - False → 두 번째 조건으로
    2. 두 번째 조건: arr9 >= 30
       - True → "B"
       - False → "C"
       
구조:
    np.where(조건1, "A",
             np.where(조건2, "B", "C"))
'''

arr9 = np.array([
    [5, 50, 95],
    [20, 75, 10],
    [60, 30, 85]
])
print('원본 2차원 배열:')
print(arr9)
print()

# 조건별 확인
print('70 이상인가?')
print(arr9 >= 70)
print()
print('30 이상인가?')
print(arr9 >= 30)
print()

# 중첩 np.where로 3단계 분류
result = np.where(arr9 >= 70, "A",           # 70 이상 → A
                  np.where(arr9 >= 30, "B",  # 30 이상 70 미만 → B
                           "C"))              # 30 미만 → C

print('9. 결과 (등급 분류):')
print(result)
# [['C' 'B' 'A']
#  ['C' 'A' 'C']
#  ['B' 'B' 'A']]
print()

# ============================================================================
# 추가 예제: np.select를 사용한 다중 조건 (더 직관적)
# ============================================================================
'''
개념 설명:
    - np.select: 여러 조건을 명확하게 표현
    - 중첩 np.where보다 가독성이 좋음
    - 조건 리스트와 값 리스트를 분리하여 관리
'''

print('=== 추가: np.select 사용법 ===')

# 조건 리스트 정의
conditions = [
    arr9 >= 70,        # 첫 번째 조건
    arr9 >= 30,        # 두 번째 조건
    # 세 번째는 default로 처리
]

# 각 조건에 대응하는 값 리스트
choices = [
    "A",  # 70 이상
    "B",  # 30 이상 70 미만
]

# np.select 사용 (default는 조건을 모두 만족하지 않을 때)
result_select = np.select(conditions, choices, default="C")
print('np.select 결과:')
print(result_select)
print()

# ============================================================================
# 핵심 개념 정리
# ============================================================================
'''
1. 불린 인덱싱:
   - 조건식으로 배열 필터링
   - & (AND), | (OR), ~ (NOT) 사용
   - 각 조건은 괄호로 묶기
   
2. np.where:
   - 조건부 값 할당
   - np.where(조건, 참일_때, 거짓일_때)
   - 중첩 사용으로 다중 조건 처리
   
3. 연산자:
   - 비교: ==, !=, <, >, <=, >=
   - 논리: & (AND), | (OR), ~ (NOT)
   - 산술: %, //, *, + 등
   
4. 실전 활용:
   - 데이터 필터링
   - 이상치 제거/처리
   - 조건부 변환
   - 등급/카테고리 분류
   - 클리핑 (범위 제한)
   
5. 성능 팁:
   - 불린 인덱싱은 벡터화 연산 (빠름)
   - 반복문보다 효율적
   - 대용량 데이터 처리에 적합
'''

# ============================================================================
# 보너스: 실전 예제 - 학생 성적 처리
# ============================================================================
print('=== 보너스: 실전 예제 ===')

# 학생 성적 데이터
scores = np.array([45, 78, 92, 35, 88, 67, 55, 98, 42, 73])
print('학생 성적:', scores)
print()

# 1. 낙제자(60점 미만) 찾기
fail = scores[scores < 60]
print('낙제자 점수:', fail)
print('낙제자 수:', len(fail), '명')
print()

# 2. 등급 부여
grades = np.where(scores >= 90, 'A',
                  np.where(scores >= 80, 'B',
                           np.where(scores >= 70, 'C',
                                    np.where(scores >= 60, 'D', 'F'))))
print('등급:', grades)
print()

# 3. 보정 (60점 미만은 60점으로 상향)
adjusted = np.where(scores < 60, 60, scores)
print('보정 후 점수:', adjusted)
print()

# 4. 통계
print(f'평균: {scores.mean():.2f}점')
print(f'최고점: {scores.max()}점')
print(f'최저점: {scores.min()}점')
print(f'합격률: {(scores >= 60).sum() / len(scores) * 100:.1f}%')

# ============================================================================
